<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport"
		content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
	<title>XGo Builder</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body,
		html {
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
			background-color: #333;
			overflow: hidden;
		}

		canvas {
			display: block;
			margin: 0;
			outline: none;
		}



		#tabs {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}

		#debug-info {
			position: absolute;
			top: 10px;
			right: 10px;
			background-color: rgba(0, 0, 0, 0.7);
			color: #fff;
			padding: 8px 12px;
			border-radius: 4px;
			font-family: monospace;
			font-size: 12px;
			max-width: 300px;
			white-space: pre-wrap;
			word-break: break-all;
			z-index: 1000;
			display: none;
		}
	</style>
</head>

<body>
	<div id="tabs">
		<div id="tab-loader">
		</div>
		<div id="tab-editor" style="display: none;">
			<canvas id="editor-canvas" tabindex="1"></canvas>
		</div>
		<div id="tab-game" style="display: none;">
			<canvas id="game-canvas" tabindex="2"></canvas>
		</div>
		<div id="debug-info"></div>
	</div>

	<script>var miniEngine = null</script>
	<script>var isWasmCompressed = false</script>
	<script src="engine.js"></script>
	<script src="storage.manager.js"></script>
	<script src="worker.message.manager.js"></script>
	<script src="go.wasm.exec.js"></script>
	<script src="game.js"></script>
	<script src="wxsdk.js"></script>
	<script>
		"use strict";
		let gameApp = null;
		let isShowEditor = false;
		let onGameErrorCallback = null;
		let debugInfoInterval = null;

		// æ›´æ–° debug info æ˜¾ç¤º
		function updateDebugInfo() {
			const debugElement = document.getElementById('debug-info');
			if (gameApp && gameApp.debugInfo && debugElement) {
				debugElement.textContent = gameApp.debugInfo;
				debugElement.style.display = 'block';
			} else if (debugElement) {
				debugElement.style.display = 'none';
			}
		}

		// å¼€å§‹ debug info æ›´æ–°
		function startDebugInfoUpdate() {
			if (debugInfoInterval) {
				clearInterval(debugInfoInterval);
			}
			debugInfoInterval = setInterval(updateDebugInfo, 1000); // æ¯ç§’æ›´æ–°ä¸€æ¬¡
		}

		// åœæ­¢ debug info æ›´æ–°
		function stopDebugInfoUpdate() {
			if (debugInfoInterval) {
				clearInterval(debugInfoInterval);
				debugInfoInterval = null;
			}
			const debugElement = document.getElementById('debug-info');
			if (debugElement) {
				debugElement.style.display = 'none';
			}
		}

		// Detect current environment, use relative path for local development, absolute path for production
		let urlPrefix = "";
		if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
			urlPrefix = ""; // Use relative path for local development
			console.log("ğŸ  Local environment detected, using local resources");
		} else {
			urlPrefix = "https://jiepengtan.github.io/miniprogram-web-game/"; // Production environment
			console.log("ğŸŒ Production environment detected, using remote resources");
		}

		if (typeof wx !== 'undefined' && wx.miniProgram) {
			console.log("ğŸ”„ wx.miniProgram detected");
		} else {
			console.log("âŒ wx.miniProgram not detected");
		}

		// Batch send cached logs
		function flushLogQueue() {
			console.log("ğŸ”„ Attempting to send cached logs, queue length:", logQueue.length);
			if (logQueue.length > 0 && typeof wx !== 'undefined' && wx.miniProgram && wx.miniProgram.postMessage) {
				console.log("âœ… Starting to send cached logs");
				const successCount = logQueue.filter((log) => {
					try {
						wx.miniProgram.postMessage({
							data: log
						});
						return true;
					} catch (error) {
						console.error("âŒ Failed to send cached log:", error);
						return false;
					}
				}).length;
				
				console.log(`âœ… Successfully sent ${successCount}/${logQueue.length} cached logs`);
				logQueue.length = 0; // Clear queue
			} else {
				console.log("âš ï¸ WeChat environment unavailable, keeping cached logs");
			}
		}

		function onProgress(value) {
			console.log("onProgress", value);
		}

		window.gdspx_on_runtime_panic = function (msg) {
			if (onGameErrorCallback != null) {
				onGameErrorCallback(msg);
			}
		}

		function onGameError(callback) {
			onGameErrorCallback = callback;
		}

		async function startGame(params) {
			console.log("ğŸ“ urlPrefix:", urlPrefix);
			try {
				await startProject(urlPrefix + params.dataUrl);
			} catch (error) {
				console.error("Stack trace:", error.stack);
				throw error;
			}
		}


		async function startProject(zipUrl) {
			isShowEditor = false;
			
			// Prepare game canvas
			const canvas = document.getElementById('game-canvas');
			if (!canvas) {
				throw new Error("Cannot find game canvas element 'game-canvas'");
			}
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
			console.log("Canvas size:", canvas.width, "x", canvas.height);
			
			// Show game canvas, hide others
			document.getElementById('tab-game').style.display = 'block';
			document.getElementById('tab-editor').style.display = 'none';
			document.getElementById('tab-loader').style.display = 'none';
			
			let buffer;
			try {
				const response = await fetch(zipUrl);
				buffer = await response.arrayBuffer();
			} catch (error) {
				throw error;
			}
			
			const config = {
				'projectName': "spx_game",
				'onProgress': onProgress,
				"gameCanvas": canvas,
				"projectData": new Uint8Array(buffer),
				"logLevel": LOG_LEVEL_VERBOSE,
				"useAssetCache": true,
				"assetURLs": {
					"engine.zip": urlPrefix + "engine.zip",
					"gdspx.wasm": urlPrefix + "gdspx.wasm",
					"engine.wasm": urlPrefix + "engine.wasm",
				},
				"onSpxReady": null,
			};

			if (gameApp != null) {
				await gameApp.StopGame();
				stopDebugInfoUpdate(); // åœæ­¢ debug info æ›´æ–°
			}

			try {
				// Try to install project and run game
				gameApp = new GameApp(config);
				await gameApp.RunGame();
				startDebugInfoUpdate(); // å¼€å§‹ debug info æ›´æ–°
			} catch (error) {
				stopDebugInfoUpdate(); // å‡ºé”™æ—¶åœæ­¢ debug info æ›´æ–°
				console.error("Stack trace:", error.stack);
				throw error;
			}
		}

		// Parse URL parameters
		function getUrlParams() {
			const urlParams = new URLSearchParams(window.location.search);
			return {
				userId: urlParams.get('userId') || 'default_user',
				dataUrl: urlParams.get('dataUrl') || 'game.zip',
				level: parseInt(urlParams.get('level')) || 1
			};
		}

		// Send message to mini program
		function sendMessageToMiniProgram(type, data) {
			if (typeof wx !== 'undefined' && wx.miniProgram) {
				console.log("sendMessageToMiniProgram", type, data);
				wx.miniProgram.postMessage({
					data: { type, data }
				});
			}
		}

		// Set error callback
		onGameError(function (callback) {
			console.error("onGameError", callback);
			stopDebugInfoUpdate(); // å‡ºé”™æ—¶åœæ­¢ debug info æ›´æ–°
			// Send error message to mini program
			sendMessageToMiniProgram('gameError', { error: callback });
		});

		// é¡µé¢å¸è½½æ—¶æ¸…ç†å®šæ—¶å™¨
		window.addEventListener('beforeunload', function() {
			stopDebugInfoUpdate();
		});

		// Wait for all scripts to load and automatically start the game
		function waitForScriptsAndStart() {
			const params = getUrlParams();
			console.log("ğŸ“‹ Received parameters:1111", params);
			sendMessageToMiniProgram(
				'web-reply',
				 'ç½‘é¡µå·²æ”¶åˆ°æ¶ˆæ¯'
			);
			startGame(params);
		}

		// Start checking scripts after DOM is loaded
		document.addEventListener('DOMContentLoaded', function() {
			console.log("DOM loaded, waiting for scripts...");
			waitForScriptsAndStart();
		});

		
        window.addEventListener('message', function(event) {
            log(`web-view ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯: ${JSON.stringify(event.data)}`);
			    // å¯é€‰ï¼šå‘å°ç¨‹åºå‘é€å›å¤
			window.parent.postMessage({
				type: 'web-reply',
				data: 'ç½‘é¡µå·²æ”¶åˆ°æ¶ˆæ¯'
			}, '*');
        });
	</script>
</body>

</html>
