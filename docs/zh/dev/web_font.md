# Web平台字体优化解决方案

## 📋 **目录**

- [🎮 问题背景](#🎮-问题背景)
- [⚙️ 当前实现](#⚙️-当前实现)
- [📅 落地计划](#📅-落地计划)
  - [阶段一](#阶段一)
  - [阶段二](#阶段二)
  - [阶段三](#阶段三)
- [🛠️ 技术实现方案](#🛠️-技术实现方案)
  - [方案1: 默认子集字体(内嵌最小集)](#方案1-默认子集字体内嵌最小集)
  - [方案2: 本地字体访问API (实验性)](#方案2-本地字体访问api-实验性)
  - [方案3: 动态字体加载系统](#方案3-动态字体加载系统)
  - [方案4: 智能字体子集化(打包时候处理, 增加游戏准备时间)](#方案4-智能字体子集化打包时候处理-增加游戏准备时间)
  - [方案5: 渐进式字体管理系统(适合具体游戏，不适合spx引擎)](#方案5-渐进式字体管理系统适合具体游戏不适合spx引擎)

---

## 🎮 **问题背景**

Spx引擎在Web平台导出时面临的字体问题：

```
Spx2 Web导出的核心问题：
├── SVG字体渲染异常
├── 影响加载速度
├── 影响下载速度 
└── 增加CDN带宽成本
```

## ⚙️ **当前实现**
- 采用内嵌一个完整字体到游戏包中 (~8M)，作为普通字体的处理
- SVG c++实现没有处理web平台无法找到系统字体的问题，导致无法正确渲染

## 📅 **落地计划**
### 阶段一 (快速修正bug)
- SVG c++ 内嵌一个800K中文字体，作为默认实现

### 阶段二
- 将游戏包中的字体 在初始化阶段传入SVG，共享同一份字体，减少包体

### 阶段三
- 采用完整策略
```
优先级0: 内嵌最小字体 (立即可用)
    ↓
优先级1: 本地字体访问API (实验性)
    ↓
优先级2: Web字体动态加载 (完整性)
```

## 🛠️ **技术实现方案**

### **方案1: 默认子集字体(内嵌最小集)**

**算法步骤：**
```
1. 预制最小字符集
   数字字符: 0-9
   英文字母: A-Z, a-z
   基础符号: .,!?@#$%^&*()+-=[]{}|;':"\/<>
   核心中文: 确定取消开始返回设置帮助关于
   
2. 字体文件预处理
   选择基础字体 (如 Roboto, Noto Sans)
   使用fonttools提取最小字符集:
      --unicodes=U+0030-0039,U+0041-005A,U+0061-007A...
      --output-file=minimal_fallback.woff2
      --flavor=woff2
   压缩优化到 < 50KB
   
3. 内嵌策略
   将字体文件编码为Base64
   直接嵌入到游戏资源中
   作为FontFile资源加载
   
4. 初始化时机
   游戏启动时立即可用
   无需网络请求
   所有UI组件的默认字体
   其他字体加载失败时的最终回退
   
5. 覆盖范围策略
   保证基本数字显示 (分数、时间)
   保证基础英文界面可读
   保证核心中文操作可理解
   支持基本标点符号显示
```

**核心优势：**
- 极小文件体积 (< 50KB)
- 零延迟立即可用
- 100%可靠性保证
- 跨语言基础支持
- 作为所有字体方案的安全网

### **方案2: 本地字体访问API (实验性)**
本地字体加载 [浏览器兼容性](https://developer.mozilla.org/en-US/docs/Web/API/Local_Font_Access_API#browser_compatibility)

**算法步骤：**
```
1. 检测运行环境
   IF 不是Web环境 THEN 返回失败
   
2. 检查浏览器API支持
   IF 浏览器支持 queryLocalFonts API THEN
      请求字体访问权限
   ELSE
      跳转到下一优先级方案
      
3. 权限处理
   IF 用户授权 THEN
      获取本地字体列表
      解析字体信息 (字体族、样式、粗细)
      触发字体检测完成事件
   ELSE
      记录权限被拒绝，使用备用方案
      
4. JavaScript桥接实现
   创建回调函数处理字体检测结果
   注册事件监听器
   执行异步字体查询
```

**核心逻辑：**
- 利用现代浏览器的本地字体访问API
- 通过JavaScript桥接与游戏引擎通信
- 异步获取系统可用字体列表
- 提供权限管理和错误处理

### **方案3: 动态字体加载系统**

**算法步骤：**
```
1. 字体请求管理
   初始化HTTP请求组件
   创建字体缓存字典
   建立加载队列机制
   
2. 异步字体加载流程
   输入: 字体族名, 配置参数
   IF 缓存中存在 THEN 直接返回
   ELSE
      构建字体URL (Google Fonts或自定义CDN)
      添加到加载队列
      开始异步下载

3. URL构建策略(可换成自定义CDN地址)
   基础URL = "https://fonts.googleapis.com/css2"
   添加字体族参数
   IF 指定字重 THEN 添加weight参数
   IF 指定子集 THEN 添加subset参数 (latin, chinese等)
   IF 指定文本 THEN 添加text参数 (只下载需要字符集 数量(eg：3000，7000))
   返回优化后的URL

4. 两阶段下载机制
   第一阶段: 下载CSS文件
      解析CSS内容
      提取真实字体文件URL
   第二阶段: 下载字体文件
      获取二进制字体数据
      创建字体资源对象
      更新缓存并触发完成事件

5. 队列处理机制
   维护下载队列状态
   实现并发控制
   处理下载失败重试
   提供进度反馈
```

**核心特性：**
- 智能缓存机制避免重复下载
- 支持字体子集化减少文件大小
- 队列管理确保下载顺序和性能
- CSS解析获取最优字体格式

### **方案4: 智能字体子集化(打包时候处理, 增加游戏准备时间，无法适配动态输入(不适合spx2))**

**算法步骤：**
```
1. 项目文本分析
   扫描所有场景文件 (.json)
   扫描所有脚本文件 (.spx)
   扫描数据文件 (.csv, .json)
   扫描svg图片 (.svg)
   
2. 字符提取策略
   使用正则表达式匹配:
      text="内容"          // UI文本
      placeholder_text="内容"  // 输入框占位符
      hint_tooltip="内容"     // 提示文本
   
3. 字符统计分析
   记录所有唯一字符
   统计字符使用频率
   检测主要语言类型
   生成字符使用报告

4. 字体子集生成
   输入: 源字体文件路径, 必需字符列表
   转换字符为Unicode编码
   调用fonttools工具:
      --unicodes=U+xxxx,U+yyyy...
      --output-file=字体_subset.woff2
      --flavor=woff2
   
5. 优化策略
   按使用频率排序字符
   分离核心字符集和扩展字符集
   生成多个子集文件
   实现渐进式字体加载
```

**技术要点：**
- 静态分析项目内容确定字符需求
- 使用外部工具(fonttools)进行字体处理
- 生成Web优化格式(WOFF2)
- 支持增量字体加载策略

### **方案5: 渐进式字体管理系统(适合具体游戏，不适合spx引擎)**

**算法步骤：**
```
1. 字体优先级定义
   MINIMAL: 内嵌最小字体 (立即可用)
   CRITICAL: 核心UI字体 (按钮、菜单)
   IMPORTANT: 内容文本字体 (对话、说明)
   OPTIONAL: 装饰字体 (特效、标题)
   PREMIUM: 高质量显示字体

2. 系统初始化流程
   立即加载MINIMAL级别字体
   创建字体检测器组件
   创建动态加载器组件
   配置加载策略字典
   启动字体加载序列

3. 加载策略配置
   FOR 每个优先级 DO
      设置字体候选列表
      定义回退字体路径
      设置最大文件大小限制
      设置加载超时时间
   
   MINIMAL级别配置:
      字体: 内嵌minimal_fallback.woff2
      文件大小: < 50KB
      加载时间: 立即可用

4. 渐进式加载序列
   第零阶段: 加载最小字体
      立即加载内嵌字体
      所有UI组件使用默认字体
      
   第一阶段: 加载关键字体
      尝试本地字体检测
      异步加载CRITICAL优先级字体
      成功获取后发出系统升级信号
   
   第二阶段: 后台加载其他字体
      FOR 优先级 IN [IMPORTANT, OPTIONAL, PREMIUM] DO
         异步加载该优先级的字体
         成功后触发字体升级事件

5. 带超时的字体加载
   并行执行:
      字体下载任务
      超时计时器
   竞争等待机制:
      IF 字体先完成 THEN 返回字体
      IF 超时先触发 THEN 使用回退字体
      最终回退: MINIMAL级别字体

6. 智能字体选择
   输入: 首选字体列表
   FOR 字体名 IN 首选列表 DO
      IF 缓存中存在 THEN 返回该字体
   IF 没有匹配 THEN 返回MINIMAL字体
```


